!STARTOFREGISTRYGENERATEDFILE 'RegistryPointers_Case09_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! RegistryPointers_Case09_Types
!.................................................................................................................................
! This file is part of RegistryPointers_Case09.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in RegistryPointers_Case09. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE RegistryPointers_Case09_Types
!---------------------------------------------------------------------------------------------------------------------------------
!USE, INTRINSIC :: ISO_C_Binding
USE NWTC_Library
IMPLICIT NONE
! =========  RegistryPointers_Case09_InitInputType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_InitInputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    CHARACTER(KIND=C_CHAR), DIMENSION(1024) :: InputFile 
    TYPE(C_ptr) :: p3DArray1 = C_NULL_PTR 
    INTEGER(C_int) :: p3DArray1_Len = 0 
    TYPE(C_PTR) :: p3DArray2(3,0,0)
    TYPE(C_ptr) :: twoDArray1 = C_NULL_PTR 
    INTEGER(C_int) :: twoDArray1_Len = 0 
    TYPE(C_PTR) :: twoDArray2(3,2)
    TYPE(C_PTR) :: twoDArray3(3,0)
  END TYPE RegistryPointers_Case09_InitInputType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_InitInputType
    TYPE( RegistryPointers_Case09_InitInputType_C ) :: C_obj
    CHARACTER(1024)  :: InputFile 
    REAL(KIND=C_FLOAT) , DIMENSION(:,:,:), POINTER  :: p3DArray1 => NULL()      !< Fortran 3D array pointer [-]
    REAL(SiKi) , DIMENSION(1:3,0:0,0:0)  :: p3DArray2      !< Fortran 3D array with last two dimensions of size 0 [-]
    REAL(KIND=C_FLOAT) , DIMENSION(:,:), POINTER  :: twoDArray1 => NULL()      !< Fortran 2D allocatable array [-]
    REAL(SiKi) , DIMENSION(1:3,1:2)  :: twoDArray2      !< Fortran 2D array [-]
    REAL(SiKi) , DIMENSION(1:3,0:0)  :: twoDArray3      !< Fortran 2D array with last dimension of size 0 [-]
  END TYPE RegistryPointers_Case09_InitInputType
! =======================
! =========  RegistryPointers_Case09_InitOutputType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_InitOutputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    TYPE(C_ptr) :: twoDArray4 = C_NULL_PTR 
    INTEGER(C_int) :: twoDArray4_Len = 0 
    TYPE(C_ptr) :: p3DArray3 = C_NULL_PTR 
    INTEGER(C_int) :: p3DArray3_Len = 0 
  END TYPE RegistryPointers_Case09_InitOutputType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_InitOutputType
    TYPE( RegistryPointers_Case09_InitOutputType_C ) :: C_obj
    REAL(KIND=C_FLOAT) , DIMENSION(:,:), POINTER  :: twoDArray4 => NULL()      !< Fortran 2D allocatable array [-]
    REAL(KIND=C_FLOAT) , DIMENSION(:,:,:), POINTER  :: p3DArray3 => NULL()      !< Fortran 3D array pointer [-]
  END TYPE RegistryPointers_Case09_InitOutputType
! =======================
! =========  RegistryPointers_Case09_ContinuousStateType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_ContinuousStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_FLOAT) :: DummyContState 
  END TYPE RegistryPointers_Case09_ContinuousStateType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_ContinuousStateType
    TYPE( RegistryPointers_Case09_ContinuousStateType_C ) :: C_obj
    REAL(SiKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE RegistryPointers_Case09_ContinuousStateType
! =======================
! =========  RegistryPointers_Case09_DiscreteStateType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_DiscreteStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_FLOAT) :: DummyDiscState 
  END TYPE RegistryPointers_Case09_DiscreteStateType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_DiscreteStateType
    TYPE( RegistryPointers_Case09_DiscreteStateType_C ) :: C_obj
    REAL(SiKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE RegistryPointers_Case09_DiscreteStateType
! =======================
! =========  RegistryPointers_Case09_ConstraintStateType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_ConstraintStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_FLOAT) :: DummyConstrState 
  END TYPE RegistryPointers_Case09_ConstraintStateType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_ConstraintStateType
    TYPE( RegistryPointers_Case09_ConstraintStateType_C ) :: C_obj
    REAL(SiKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE RegistryPointers_Case09_ConstraintStateType
! =======================
! =========  RegistryPointers_Case09_OtherStateType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_OtherStateType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    INTEGER(KIND=C_INT) :: DummyOtherState 
  END TYPE RegistryPointers_Case09_OtherStateType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_OtherStateType
    TYPE( RegistryPointers_Case09_OtherStateType_C ) :: C_obj
    INTEGER(IntKi)  :: DummyOtherState      !< Remove this variable if you have other states [-]
  END TYPE RegistryPointers_Case09_OtherStateType
! =======================
! =========  RegistryPointers_Case09_MiscVarType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_MiscVarType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    INTEGER(KIND=C_INT) :: DummyMiscVar 
  END TYPE RegistryPointers_Case09_MiscVarType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_MiscVarType
    TYPE( RegistryPointers_Case09_MiscVarType_C ) :: C_obj
    INTEGER(IntKi)  :: DummyMiscVar      !< Remove this variable if you have misc/optimization variables [-]
  END TYPE RegistryPointers_Case09_MiscVarType
! =======================
! =========  RegistryPointers_Case09_ParameterType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_ParameterType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_DOUBLE) :: DT 
    TYPE(C_ptr) :: p3DArray = C_NULL_PTR 
    INTEGER(C_int) :: p3DArray_Len = 0 
  END TYPE RegistryPointers_Case09_ParameterType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_ParameterType
    TYPE( RegistryPointers_Case09_ParameterType_C ) :: C_obj
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [seconds]
    REAL(KIND=C_FLOAT) , DIMENSION(:,:,:), POINTER  :: p3DArray => NULL()      !< Fortran 3D Array pointer [-]
  END TYPE RegistryPointers_Case09_ParameterType
! =======================
! =========  RegistryPointers_Case09_InputType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_InputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_FLOAT) :: DummyInput 
  END TYPE RegistryPointers_Case09_InputType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_InputType
    TYPE( RegistryPointers_Case09_InputType_C ) :: C_obj
    REAL(SiKi)  :: DummyInput      !< Remove this variable if you have input data [-]
  END TYPE RegistryPointers_Case09_InputType
! =======================
! =========  RegistryPointers_Case09_OutputType_C  =======
  TYPE, BIND(C) :: RegistryPointers_Case09_OutputType_C
   TYPE(C_PTR) :: object = C_NULL_PTR
    REAL(KIND=C_FLOAT) :: DummyOutput 
  END TYPE RegistryPointers_Case09_OutputType_C
  TYPE, PUBLIC :: RegistryPointers_Case09_OutputType
    TYPE( RegistryPointers_Case09_OutputType_C ) :: C_obj
    REAL(SiKi)  :: DummyOutput      !< Remove this variable if you have output data [-]
  END TYPE RegistryPointers_Case09_OutputType
! =======================
CONTAINS
 SUBROUTINE RegistryPointers_Case09_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(RegistryPointers_Case09_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%C_obj%InputFile = SrcInitInputData%C_obj%InputFile
IF (ASSOCIATED(SrcInitInputData%p3DArray1)) THEN
  i1_l = LBOUND(SrcInitInputData%p3DArray1,1)
  i1_u = UBOUND(SrcInitInputData%p3DArray1,1)
  i2_l = LBOUND(SrcInitInputData%p3DArray1,2)
  i2_u = UBOUND(SrcInitInputData%p3DArray1,2)
  i3_l = LBOUND(SrcInitInputData%p3DArray1,3)
  i3_u = UBOUND(SrcInitInputData%p3DArray1,3)
  IF (.NOT. ASSOCIATED(DstInitInputData%p3DArray1)) THEN 
    ALLOCATE(DstInitInputData%p3DArray1(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%p3DArray1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
    DstInitInputData%c_obj%p3DArray1_Len = SIZE(DstInitInputData%p3DArray1)
    IF (DstInitInputData%c_obj%p3DArray1_Len > 0) &
      DstInitInputData%c_obj%p3DArray1 = C_LOC( DstInitInputData%p3DArray1(i1_l) ) 
  END IF
    DstInitInputData%p3DArray1 = SrcInitInputData%p3DArray1
ENDIF
IF (ALLOCATED(SrcInitInputData%p3DArray2)) THEN
  i1_l = LBOUND(SrcInitInputData%p3DArray2,1)
  i1_u = UBOUND(SrcInitInputData%p3DArray2,1)
  i2_l = LBOUND(SrcInitInputData%p3DArray2,2)
  i2_u = UBOUND(SrcInitInputData%p3DArray2,2)
  i3_l = LBOUND(SrcInitInputData%p3DArray2,3)
  i3_u = UBOUND(SrcInitInputData%p3DArray2,3)
  IF (.NOT. ALLOCATED(DstInitInputData%p3DArray2)) THEN 
    ALLOCATE(DstInitInputData%p3DArray2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%p3DArray2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%p3DArray2 = SrcInitInputData%p3DArray2
ENDIF
IF (ASSOCIATED(SrcInitInputData%twoDArray1)) THEN
  i1_l = LBOUND(SrcInitInputData%twoDArray1,1)
  i1_u = UBOUND(SrcInitInputData%twoDArray1,1)
  i2_l = LBOUND(SrcInitInputData%twoDArray1,2)
  i2_u = UBOUND(SrcInitInputData%twoDArray1,2)
  IF (.NOT. ASSOCIATED(DstInitInputData%twoDArray1)) THEN 
    ALLOCATE(DstInitInputData%twoDArray1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%twoDArray1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
    DstInitInputData%c_obj%twoDArray1_Len = SIZE(DstInitInputData%twoDArray1)
    IF (DstInitInputData%c_obj%twoDArray1_Len > 0) &
      DstInitInputData%c_obj%twoDArray1 = C_LOC( DstInitInputData%twoDArray1(i1_l) ) 
  END IF
    DstInitInputData%twoDArray1 = SrcInitInputData%twoDArray1
ENDIF
    DstInitInputData%twoDArray2 = SrcInitInputData%twoDArray2
IF (ALLOCATED(SrcInitInputData%twoDArray3)) THEN
  i1_l = LBOUND(SrcInitInputData%twoDArray3,1)
  i1_u = UBOUND(SrcInitInputData%twoDArray3,1)
  i2_l = LBOUND(SrcInitInputData%twoDArray3,2)
  i2_u = UBOUND(SrcInitInputData%twoDArray3,2)
  IF (.NOT. ALLOCATED(DstInitInputData%twoDArray3)) THEN 
    ALLOCATE(DstInitInputData%twoDArray3(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%twoDArray3.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%twoDArray3 = SrcInitInputData%twoDArray3
ENDIF
 END SUBROUTINE RegistryPointers_Case09_CopyInitInput

 SUBROUTINE RegistryPointers_Case09_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(InitInputData%p3DArray1)) THEN
  DEALLOCATE(InitInputData%p3DArray1)
  InitInputData%p3DArray1 => NULL()
  InitInputData%C_obj%p3DArray1 = C_NULL_PTR
  InitInputData%C_obj%p3DArray1_Len = 0
ENDIF
IF (ALLOCATED(InitInputData%p3DArray2)) THEN
  DEALLOCATE(InitInputData%p3DArray2)
ENDIF
IF (ASSOCIATED(InitInputData%twoDArray1)) THEN
  DEALLOCATE(InitInputData%twoDArray1)
  InitInputData%twoDArray1 => NULL()
  InitInputData%C_obj%twoDArray1 = C_NULL_PTR
  InitInputData%C_obj%twoDArray1_Len = 0
ENDIF
IF (ALLOCATED(InitInputData%twoDArray3)) THEN
  DEALLOCATE(InitInputData%twoDArray3)
ENDIF
 END SUBROUTINE RegistryPointers_Case09_DestroyInitInput

 SUBROUTINE RegistryPointers_Case09_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%InputFile)  ! InputFile
  Int_BufSz   = Int_BufSz   + 1     ! p3DArray1 allocated yes/no
  IF ( ASSOCIATED(InData%p3DArray1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! p3DArray1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%p3DArray1)  ! p3DArray1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! p3DArray2 allocated yes/no
  IF ( ALLOCATED(InData%p3DArray2) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! p3DArray2 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%p3DArray2)  ! p3DArray2
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! twoDArray1 allocated yes/no
  IF ( ASSOCIATED(InData%twoDArray1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! twoDArray1 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%twoDArray1)  ! twoDArray1
  END IF
      Re_BufSz   = Re_BufSz   + SIZE(InData%twoDArray2)  ! twoDArray2
  Int_BufSz   = Int_BufSz   + 1     ! twoDArray3 allocated yes/no
  IF ( ALLOCATED(InData%twoDArray3) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! twoDArray3 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%twoDArray3)  ! twoDArray3
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DO I = 1, LEN(InData%InputFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%InputFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
  IF ( .NOT. ASSOCIATED(InData%p3DArray1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray1,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray1,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray1,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%p3DArray1,3), UBOUND(InData%p3DArray1,3)
        DO i2 = LBOUND(InData%p3DArray1,2), UBOUND(InData%p3DArray1,2)
          DO i1 = LBOUND(InData%p3DArray1,1), UBOUND(InData%p3DArray1,1)
            ReKiBuf(Re_Xferred) = InData%p3DArray1(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%p3DArray2) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray2,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray2,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray2,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray2,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray2,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray2,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%p3DArray2,3), UBOUND(InData%p3DArray2,3)
        DO i2 = LBOUND(InData%p3DArray2,2), UBOUND(InData%p3DArray2,2)
          DO i1 = LBOUND(InData%p3DArray2,1), UBOUND(InData%p3DArray2,1)
            ReKiBuf(Re_Xferred) = InData%p3DArray2(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ASSOCIATED(InData%twoDArray1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray1,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray1,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray1,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%twoDArray1,2), UBOUND(InData%twoDArray1,2)
        DO i1 = LBOUND(InData%twoDArray1,1), UBOUND(InData%twoDArray1,1)
          ReKiBuf(Re_Xferred) = InData%twoDArray1(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    DO i2 = LBOUND(InData%twoDArray2,2), UBOUND(InData%twoDArray2,2)
      DO i1 = LBOUND(InData%twoDArray2,1), UBOUND(InData%twoDArray2,1)
        ReKiBuf(Re_Xferred) = InData%twoDArray2(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
  IF ( .NOT. ALLOCATED(InData%twoDArray3) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray3,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray3,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray3,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray3,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%twoDArray3,2), UBOUND(InData%twoDArray3,2)
        DO i1 = LBOUND(InData%twoDArray3,1), UBOUND(InData%twoDArray3,1)
          ReKiBuf(Re_Xferred) = InData%twoDArray3(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_PackInitInput

 SUBROUTINE RegistryPointers_Case09_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    DO I = 1, LEN(OutData%InputFile)
      OutData%InputFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
      OutData%C_obj%InputFile = TRANSFER(OutData%InputFile, OutData%C_obj%InputFile )
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! p3DArray1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ASSOCIATED(OutData%p3DArray1)) DEALLOCATE(OutData%p3DArray1)
    ALLOCATE(OutData%p3DArray1(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%p3DArray1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    OutData%c_obj%p3DArray1_Len = SIZE(OutData%p3DArray1)
    IF (OutData%c_obj%p3DArray1_Len > 0) &
       OutData%c_obj%p3DArray1 = C_LOC( OutData%p3DArray1(i1_l) ) 
      DO i3 = LBOUND(OutData%p3DArray1,3), UBOUND(OutData%p3DArray1,3)
        DO i2 = LBOUND(OutData%p3DArray1,2), UBOUND(OutData%p3DArray1,2)
          DO i1 = LBOUND(OutData%p3DArray1,1), UBOUND(OutData%p3DArray1,1)
            OutData%p3DArray1(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), C_FLOAT)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! p3DArray2 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%p3DArray2)) DEALLOCATE(OutData%p3DArray2)
    ALLOCATE(OutData%p3DArray2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%p3DArray2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%p3DArray2,3), UBOUND(OutData%p3DArray2,3)
        DO i2 = LBOUND(OutData%p3DArray2,2), UBOUND(OutData%p3DArray2,2)
          DO i1 = LBOUND(OutData%p3DArray2,1), UBOUND(OutData%p3DArray2,1)
            OutData%p3DArray2(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! twoDArray1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ASSOCIATED(OutData%twoDArray1)) DEALLOCATE(OutData%twoDArray1)
    ALLOCATE(OutData%twoDArray1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%twoDArray1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    OutData%c_obj%twoDArray1_Len = SIZE(OutData%twoDArray1)
    IF (OutData%c_obj%twoDArray1_Len > 0) &
       OutData%c_obj%twoDArray1 = C_LOC( OutData%twoDArray1(i1_l) ) 
      DO i2 = LBOUND(OutData%twoDArray1,2), UBOUND(OutData%twoDArray1,2)
        DO i1 = LBOUND(OutData%twoDArray1,1), UBOUND(OutData%twoDArray1,1)
          OutData%twoDArray1(i1,i2) = REAL(ReKiBuf(Re_Xferred), C_FLOAT)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%twoDArray2,1)
    i1_u = UBOUND(OutData%twoDArray2,1)
    i2_l = LBOUND(OutData%twoDArray2,2)
    i2_u = UBOUND(OutData%twoDArray2,2)
    DO i2 = LBOUND(OutData%twoDArray2,2), UBOUND(OutData%twoDArray2,2)
      DO i1 = LBOUND(OutData%twoDArray2,1), UBOUND(OutData%twoDArray2,1)
        OutData%twoDArray2(i1,i2) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! twoDArray3 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%twoDArray3)) DEALLOCATE(OutData%twoDArray3)
    ALLOCATE(OutData%twoDArray3(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%twoDArray3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%twoDArray3,2), UBOUND(OutData%twoDArray3,2)
        DO i1 = LBOUND(OutData%twoDArray3,1), UBOUND(OutData%twoDArray3,1)
          OutData%twoDArray3(i1,i2) = REAL(ReKiBuf(Re_Xferred), SiKi)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_UnPackInitInput

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInitInput( InitInputData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_InitInputType), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    InitInputData%InputFile = TRANSFER(InitInputData%C_obj%InputFile, InitInputData%InputFile )

    ! -- p3DArray1 InitInput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. C_ASSOCIATED( InitInputData%C_obj%p3DArray1 ) ) THEN
          NULLIFY( InitInputData%p3DArray1 )
       ELSE
          CALL C_F_POINTER(InitInputData%C_obj%p3DArray1, InitInputData%p3DArray1, (/InitInputData%C_obj%p3DArray1_Len/))
       END IF
    END IF

    ! -- twoDArray1 InitInput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. C_ASSOCIATED( InitInputData%C_obj%twoDArray1 ) ) THEN
          NULLIFY( InitInputData%twoDArray1 )
       ELSE
          CALL C_F_POINTER(InitInputData%C_obj%twoDArray1, InitInputData%twoDArray1, (/InitInputData%C_obj%twoDArray1_Len/))
       END IF
    END IF
    InitInputData%twoDArray2 = InitInputData%C_obj%twoDArray2
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInitInput

 SUBROUTINE RegistryPointers_Case09_F2C_CopyInitInput( InitInputData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_InitInputType), INTENT(INOUT) :: InitInputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    InitInputData%C_obj%InputFile = TRANSFER(InitInputData%InputFile, InitInputData%C_obj%InputFile )

    ! -- p3DArray1 InitInput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. ASSOCIATED(InitInputData%p3DArray1)) THEN 
          InitInputData%c_obj%p3DArray1_Len = 0
          InitInputData%c_obj%p3DArray1 = C_NULL_PTR
       ELSE
          InitInputData%c_obj%p3DArray1_Len = SIZE(InitInputData%p3DArray1)
          IF (InitInputData%c_obj%p3DArray1_Len > 0) &
             InitInputData%c_obj%p3DArray1 = C_LOC( InitInputData%p3DArray1( LBOUND(InitInputData%p3DArray1,1) ) ) 
       END IF
    END IF

    ! -- twoDArray1 InitInput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. ASSOCIATED(InitInputData%twoDArray1)) THEN 
          InitInputData%c_obj%twoDArray1_Len = 0
          InitInputData%c_obj%twoDArray1 = C_NULL_PTR
       ELSE
          InitInputData%c_obj%twoDArray1_Len = SIZE(InitInputData%twoDArray1)
          IF (InitInputData%c_obj%twoDArray1_Len > 0) &
             InitInputData%c_obj%twoDArray1 = C_LOC( InitInputData%twoDArray1( LBOUND(InitInputData%twoDArray1,1) ) ) 
       END IF
    END IF
    InitInputData%C_obj%twoDArray2 = InitInputData%twoDArray2
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyInitInput

 SUBROUTINE RegistryPointers_Case09_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(RegistryPointers_Case09_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcInitOutputData%twoDArray4)) THEN
  i1_l = LBOUND(SrcInitOutputData%twoDArray4,1)
  i1_u = UBOUND(SrcInitOutputData%twoDArray4,1)
  i2_l = LBOUND(SrcInitOutputData%twoDArray4,2)
  i2_u = UBOUND(SrcInitOutputData%twoDArray4,2)
  IF (.NOT. ASSOCIATED(DstInitOutputData%twoDArray4)) THEN 
    ALLOCATE(DstInitOutputData%twoDArray4(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%twoDArray4.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
    DstInitOutputData%c_obj%twoDArray4_Len = SIZE(DstInitOutputData%twoDArray4)
    IF (DstInitOutputData%c_obj%twoDArray4_Len > 0) &
      DstInitOutputData%c_obj%twoDArray4 = C_LOC( DstInitOutputData%twoDArray4(i1_l) ) 
  END IF
    DstInitOutputData%twoDArray4 = SrcInitOutputData%twoDArray4
ENDIF
IF (ASSOCIATED(SrcInitOutputData%p3DArray3)) THEN
  i1_l = LBOUND(SrcInitOutputData%p3DArray3,1)
  i1_u = UBOUND(SrcInitOutputData%p3DArray3,1)
  i2_l = LBOUND(SrcInitOutputData%p3DArray3,2)
  i2_u = UBOUND(SrcInitOutputData%p3DArray3,2)
  i3_l = LBOUND(SrcInitOutputData%p3DArray3,3)
  i3_u = UBOUND(SrcInitOutputData%p3DArray3,3)
  IF (.NOT. ASSOCIATED(DstInitOutputData%p3DArray3)) THEN 
    ALLOCATE(DstInitOutputData%p3DArray3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%p3DArray3.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
    DstInitOutputData%c_obj%p3DArray3_Len = SIZE(DstInitOutputData%p3DArray3)
    IF (DstInitOutputData%c_obj%p3DArray3_Len > 0) &
      DstInitOutputData%c_obj%p3DArray3 = C_LOC( DstInitOutputData%p3DArray3(i1_l) ) 
  END IF
    DstInitOutputData%p3DArray3 = SrcInitOutputData%p3DArray3
ENDIF
 END SUBROUTINE RegistryPointers_Case09_CopyInitOutput

 SUBROUTINE RegistryPointers_Case09_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(InitOutputData%twoDArray4)) THEN
  DEALLOCATE(InitOutputData%twoDArray4)
  InitOutputData%twoDArray4 => NULL()
  InitOutputData%C_obj%twoDArray4 = C_NULL_PTR
  InitOutputData%C_obj%twoDArray4_Len = 0
ENDIF
IF (ASSOCIATED(InitOutputData%p3DArray3)) THEN
  DEALLOCATE(InitOutputData%p3DArray3)
  InitOutputData%p3DArray3 => NULL()
  InitOutputData%C_obj%p3DArray3 = C_NULL_PTR
  InitOutputData%C_obj%p3DArray3_Len = 0
ENDIF
 END SUBROUTINE RegistryPointers_Case09_DestroyInitOutput

 SUBROUTINE RegistryPointers_Case09_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! twoDArray4 allocated yes/no
  IF ( ASSOCIATED(InData%twoDArray4) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! twoDArray4 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%twoDArray4)  ! twoDArray4
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! p3DArray3 allocated yes/no
  IF ( ASSOCIATED(InData%p3DArray3) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! p3DArray3 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%p3DArray3)  ! p3DArray3
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ASSOCIATED(InData%twoDArray4) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray4,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray4,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%twoDArray4,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%twoDArray4,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%twoDArray4,2), UBOUND(InData%twoDArray4,2)
        DO i1 = LBOUND(InData%twoDArray4,1), UBOUND(InData%twoDArray4,1)
          ReKiBuf(Re_Xferred) = InData%twoDArray4(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ASSOCIATED(InData%p3DArray3) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray3,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray3,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray3,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray3,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray3,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray3,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%p3DArray3,3), UBOUND(InData%p3DArray3,3)
        DO i2 = LBOUND(InData%p3DArray3,2), UBOUND(InData%p3DArray3,2)
          DO i1 = LBOUND(InData%p3DArray3,1), UBOUND(InData%p3DArray3,1)
            ReKiBuf(Re_Xferred) = InData%p3DArray3(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_PackInitOutput

 SUBROUTINE RegistryPointers_Case09_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! twoDArray4 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ASSOCIATED(OutData%twoDArray4)) DEALLOCATE(OutData%twoDArray4)
    ALLOCATE(OutData%twoDArray4(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%twoDArray4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    OutData%c_obj%twoDArray4_Len = SIZE(OutData%twoDArray4)
    IF (OutData%c_obj%twoDArray4_Len > 0) &
       OutData%c_obj%twoDArray4 = C_LOC( OutData%twoDArray4(i1_l) ) 
      DO i2 = LBOUND(OutData%twoDArray4,2), UBOUND(OutData%twoDArray4,2)
        DO i1 = LBOUND(OutData%twoDArray4,1), UBOUND(OutData%twoDArray4,1)
          OutData%twoDArray4(i1,i2) = REAL(ReKiBuf(Re_Xferred), C_FLOAT)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! p3DArray3 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ASSOCIATED(OutData%p3DArray3)) DEALLOCATE(OutData%p3DArray3)
    ALLOCATE(OutData%p3DArray3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%p3DArray3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    OutData%c_obj%p3DArray3_Len = SIZE(OutData%p3DArray3)
    IF (OutData%c_obj%p3DArray3_Len > 0) &
       OutData%c_obj%p3DArray3 = C_LOC( OutData%p3DArray3(i1_l) ) 
      DO i3 = LBOUND(OutData%p3DArray3,3), UBOUND(OutData%p3DArray3,3)
        DO i2 = LBOUND(OutData%p3DArray3,2), UBOUND(OutData%p3DArray3,2)
          DO i1 = LBOUND(OutData%p3DArray3,1), UBOUND(OutData%p3DArray3,1)
            OutData%p3DArray3(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), C_FLOAT)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_UnPackInitOutput

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInitOutput( InitOutputData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_InitOutputType), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF

    ! -- twoDArray4 InitOutput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. C_ASSOCIATED( InitOutputData%C_obj%twoDArray4 ) ) THEN
          NULLIFY( InitOutputData%twoDArray4 )
       ELSE
          CALL C_F_POINTER(InitOutputData%C_obj%twoDArray4, InitOutputData%twoDArray4, (/InitOutputData%C_obj%twoDArray4_Len/))
       END IF
    END IF

    ! -- p3DArray3 InitOutput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. C_ASSOCIATED( InitOutputData%C_obj%p3DArray3 ) ) THEN
          NULLIFY( InitOutputData%p3DArray3 )
       ELSE
          CALL C_F_POINTER(InitOutputData%C_obj%p3DArray3, InitOutputData%p3DArray3, (/InitOutputData%C_obj%p3DArray3_Len/))
       END IF
    END IF
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInitOutput

 SUBROUTINE RegistryPointers_Case09_F2C_CopyInitOutput( InitOutputData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_InitOutputType), INTENT(INOUT) :: InitOutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF

    ! -- twoDArray4 InitOutput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. ASSOCIATED(InitOutputData%twoDArray4)) THEN 
          InitOutputData%c_obj%twoDArray4_Len = 0
          InitOutputData%c_obj%twoDArray4 = C_NULL_PTR
       ELSE
          InitOutputData%c_obj%twoDArray4_Len = SIZE(InitOutputData%twoDArray4)
          IF (InitOutputData%c_obj%twoDArray4_Len > 0) &
             InitOutputData%c_obj%twoDArray4 = C_LOC( InitOutputData%twoDArray4( LBOUND(InitOutputData%twoDArray4,1) ) ) 
       END IF
    END IF

    ! -- p3DArray3 InitOutput Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. ASSOCIATED(InitOutputData%p3DArray3)) THEN 
          InitOutputData%c_obj%p3DArray3_Len = 0
          InitOutputData%c_obj%p3DArray3 = C_NULL_PTR
       ELSE
          InitOutputData%c_obj%p3DArray3_Len = SIZE(InitOutputData%p3DArray3)
          IF (InitOutputData%c_obj%p3DArray3_Len > 0) &
             InitOutputData%c_obj%p3DArray3 = C_LOC( InitOutputData%p3DArray3( LBOUND(InitOutputData%p3DArray3,1) ) ) 
       END IF
    END IF
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyInitOutput

 SUBROUTINE RegistryPointers_Case09_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
    DstContStateData%C_obj%DummyContState = SrcContStateData%C_obj%DummyContState
 END SUBROUTINE RegistryPointers_Case09_CopyContState

 SUBROUTINE RegistryPointers_Case09_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyContState

 SUBROUTINE RegistryPointers_Case09_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyContState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackContState

 SUBROUTINE RegistryPointers_Case09_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyContState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      OutData%C_obj%DummyContState = OutData%DummyContState
 END SUBROUTINE RegistryPointers_Case09_UnPackContState

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyContState( ContStateData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ContStateData%DummyContState = ContStateData%C_obj%DummyContState
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyContState

 SUBROUTINE RegistryPointers_Case09_F2C_CopyContState( ContStateData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_ContinuousStateType), INTENT(INOUT) :: ContStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ContStateData%C_obj%DummyContState = ContStateData%DummyContState
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyContState

 SUBROUTINE RegistryPointers_Case09_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
    DstDiscStateData%C_obj%DummyDiscState = SrcDiscStateData%C_obj%DummyDiscState
 END SUBROUTINE RegistryPointers_Case09_CopyDiscState

 SUBROUTINE RegistryPointers_Case09_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyDiscState

 SUBROUTINE RegistryPointers_Case09_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyDiscState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackDiscState

 SUBROUTINE RegistryPointers_Case09_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyDiscState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      OutData%C_obj%DummyDiscState = OutData%DummyDiscState
 END SUBROUTINE RegistryPointers_Case09_UnPackDiscState

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyDiscState( DiscStateData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    DiscStateData%DummyDiscState = DiscStateData%C_obj%DummyDiscState
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyDiscState

 SUBROUTINE RegistryPointers_Case09_F2C_CopyDiscState( DiscStateData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_DiscreteStateType), INTENT(INOUT) :: DiscStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    DiscStateData%C_obj%DummyDiscState = DiscStateData%DummyDiscState
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyDiscState

 SUBROUTINE RegistryPointers_Case09_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
    DstConstrStateData%C_obj%DummyConstrState = SrcConstrStateData%C_obj%DummyConstrState
 END SUBROUTINE RegistryPointers_Case09_CopyConstrState

 SUBROUTINE RegistryPointers_Case09_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyConstrState

 SUBROUTINE RegistryPointers_Case09_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyConstrState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackConstrState

 SUBROUTINE RegistryPointers_Case09_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyConstrState = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      OutData%C_obj%DummyConstrState = OutData%DummyConstrState
 END SUBROUTINE RegistryPointers_Case09_UnPackConstrState

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyConstrState( ConstrStateData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ConstrStateData%DummyConstrState = ConstrStateData%C_obj%DummyConstrState
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyConstrState

 SUBROUTINE RegistryPointers_Case09_F2C_CopyConstrState( ConstrStateData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ConstrStateData%C_obj%DummyConstrState = ConstrStateData%DummyConstrState
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyConstrState

 SUBROUTINE RegistryPointers_Case09_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(RegistryPointers_Case09_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
    DstOtherStateData%C_obj%DummyOtherState = SrcOtherStateData%C_obj%DummyOtherState
 END SUBROUTINE RegistryPointers_Case09_CopyOtherState

 SUBROUTINE RegistryPointers_Case09_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyOtherState

 SUBROUTINE RegistryPointers_Case09_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! DummyOtherState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%DummyOtherState
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackOtherState

 SUBROUTINE RegistryPointers_Case09_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyOtherState = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
      OutData%C_obj%DummyOtherState = OutData%DummyOtherState
 END SUBROUTINE RegistryPointers_Case09_UnPackOtherState

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyOtherState( OtherStateData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_OtherStateType), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    OtherStateData%DummyOtherState = OtherStateData%C_obj%DummyOtherState
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyOtherState

 SUBROUTINE RegistryPointers_Case09_F2C_CopyOtherState( OtherStateData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_OtherStateType), INTENT(INOUT) :: OtherStateData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    OtherStateData%C_obj%DummyOtherState = OtherStateData%DummyOtherState
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyOtherState

 SUBROUTINE RegistryPointers_Case09_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(RegistryPointers_Case09_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%DummyMiscVar = SrcMiscData%DummyMiscVar
    DstMiscData%C_obj%DummyMiscVar = SrcMiscData%C_obj%DummyMiscVar
 END SUBROUTINE RegistryPointers_Case09_CopyMisc

 SUBROUTINE RegistryPointers_Case09_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyMisc

 SUBROUTINE RegistryPointers_Case09_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! DummyMiscVar
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%DummyMiscVar
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackMisc

 SUBROUTINE RegistryPointers_Case09_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyMiscVar = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
      OutData%C_obj%DummyMiscVar = OutData%DummyMiscVar
 END SUBROUTINE RegistryPointers_Case09_UnPackMisc

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyMisc( MiscData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_MiscVarType), INTENT(INOUT) :: MiscData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    MiscData%DummyMiscVar = MiscData%C_obj%DummyMiscVar
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyMisc

 SUBROUTINE RegistryPointers_Case09_F2C_CopyMisc( MiscData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_MiscVarType), INTENT(INOUT) :: MiscData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    MiscData%C_obj%DummyMiscVar = MiscData%DummyMiscVar
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyMisc

 SUBROUTINE RegistryPointers_Case09_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(RegistryPointers_Case09_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%C_obj%DT = SrcParamData%C_obj%DT
IF (ASSOCIATED(SrcParamData%p3DArray)) THEN
  i1_l = LBOUND(SrcParamData%p3DArray,1)
  i1_u = UBOUND(SrcParamData%p3DArray,1)
  i2_l = LBOUND(SrcParamData%p3DArray,2)
  i2_u = UBOUND(SrcParamData%p3DArray,2)
  i3_l = LBOUND(SrcParamData%p3DArray,3)
  i3_u = UBOUND(SrcParamData%p3DArray,3)
  IF (.NOT. ASSOCIATED(DstParamData%p3DArray)) THEN 
    ALLOCATE(DstParamData%p3DArray(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%p3DArray.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
    DstParamData%c_obj%p3DArray_Len = SIZE(DstParamData%p3DArray)
    IF (DstParamData%c_obj%p3DArray_Len > 0) &
      DstParamData%c_obj%p3DArray = C_LOC( DstParamData%p3DArray(i1_l) ) 
  END IF
    DstParamData%p3DArray = SrcParamData%p3DArray
ENDIF
 END SUBROUTINE RegistryPointers_Case09_CopyParam

 SUBROUTINE RegistryPointers_Case09_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ASSOCIATED(ParamData%p3DArray)) THEN
  DEALLOCATE(ParamData%p3DArray)
  ParamData%p3DArray => NULL()
  ParamData%C_obj%p3DArray = C_NULL_PTR
  ParamData%C_obj%p3DArray_Len = 0
ENDIF
 END SUBROUTINE RegistryPointers_Case09_DestroyParam

 SUBROUTINE RegistryPointers_Case09_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz   = Int_BufSz   + 1     ! p3DArray allocated yes/no
  IF ( ASSOCIATED(InData%p3DArray) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! p3DArray upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%p3DArray)  ! p3DArray
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DbKiBuf(Db_Xferred) = InData%DT
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ASSOCIATED(InData%p3DArray) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%p3DArray,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%p3DArray,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%p3DArray,3), UBOUND(InData%p3DArray,3)
        DO i2 = LBOUND(InData%p3DArray,2), UBOUND(InData%p3DArray,2)
          DO i1 = LBOUND(InData%p3DArray,1), UBOUND(InData%p3DArray,1)
            ReKiBuf(Re_Xferred) = InData%p3DArray(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_PackParam

 SUBROUTINE RegistryPointers_Case09_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DT = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
      OutData%C_obj%DT = OutData%DT
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! p3DArray not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ASSOCIATED(OutData%p3DArray)) DEALLOCATE(OutData%p3DArray)
    ALLOCATE(OutData%p3DArray(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%p3DArray.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    OutData%c_obj%p3DArray_Len = SIZE(OutData%p3DArray)
    IF (OutData%c_obj%p3DArray_Len > 0) &
       OutData%c_obj%p3DArray = C_LOC( OutData%p3DArray(i1_l) ) 
      DO i3 = LBOUND(OutData%p3DArray,3), UBOUND(OutData%p3DArray,3)
        DO i2 = LBOUND(OutData%p3DArray,2), UBOUND(OutData%p3DArray,2)
          DO i1 = LBOUND(OutData%p3DArray,1), UBOUND(OutData%p3DArray,1)
            OutData%p3DArray(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), C_FLOAT)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE RegistryPointers_Case09_UnPackParam

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyParam( ParamData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_ParameterType), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ParamData%DT = ParamData%C_obj%DT

    ! -- p3DArray Param Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. C_ASSOCIATED( ParamData%C_obj%p3DArray ) ) THEN
          NULLIFY( ParamData%p3DArray )
       ELSE
          CALL C_F_POINTER(ParamData%C_obj%p3DArray, ParamData%p3DArray, (/ParamData%C_obj%p3DArray_Len/))
       END IF
    END IF
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyParam

 SUBROUTINE RegistryPointers_Case09_F2C_CopyParam( ParamData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_ParameterType), INTENT(INOUT) :: ParamData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    ParamData%C_obj%DT = ParamData%DT

    ! -- p3DArray Param Data fields
    IF ( .NOT. SkipPointers_local ) THEN
       IF ( .NOT. ASSOCIATED(ParamData%p3DArray)) THEN 
          ParamData%c_obj%p3DArray_Len = 0
          ParamData%c_obj%p3DArray = C_NULL_PTR
       ELSE
          ParamData%c_obj%p3DArray_Len = SIZE(ParamData%p3DArray)
          IF (ParamData%c_obj%p3DArray_Len > 0) &
             ParamData%c_obj%p3DArray = C_LOC( ParamData%p3DArray( LBOUND(ParamData%p3DArray,1) ) ) 
       END IF
    END IF
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyParam

 SUBROUTINE RegistryPointers_Case09_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_InputType), INTENT(IN) :: SrcInputData
   TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputData%DummyInput = SrcInputData%DummyInput
    DstInputData%C_obj%DummyInput = SrcInputData%C_obj%DummyInput
 END SUBROUTINE RegistryPointers_Case09_CopyInput

 SUBROUTINE RegistryPointers_Case09_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyInput

 SUBROUTINE RegistryPointers_Case09_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyInput
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyInput
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackInput

 SUBROUTINE RegistryPointers_Case09_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyInput = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      OutData%C_obj%DummyInput = OutData%DummyInput
 END SUBROUTINE RegistryPointers_Case09_UnPackInput

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInput( InputData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    InputData%DummyInput = InputData%C_obj%DummyInput
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyInput

 SUBROUTINE RegistryPointers_Case09_F2C_CopyInput( InputData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT) :: InputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    InputData%C_obj%DummyInput = InputData%DummyInput
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyInput

 SUBROUTINE RegistryPointers_Case09_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RegistryPointers_Case09_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOutputData%DummyOutput = SrcOutputData%DummyOutput
    DstOutputData%C_obj%DummyOutput = SrcOutputData%C_obj%DummyOutput
 END SUBROUTINE RegistryPointers_Case09_CopyOutput

 SUBROUTINE RegistryPointers_Case09_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'RegistryPointers_Case09_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE RegistryPointers_Case09_DestroyOutput

 SUBROUTINE RegistryPointers_Case09_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyOutput
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  IF (C_ASSOCIATED(InData%C_obj%object)) CALL SetErrStat(ErrID_Severe,'C_obj%object cannot be packed.',ErrStat,ErrMsg,RoutineName)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyOutput
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE RegistryPointers_Case09_PackOutput

 SUBROUTINE RegistryPointers_Case09_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'RegistryPointers_Case09_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyOutput = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      OutData%C_obj%DummyOutput = OutData%DummyOutput
 END SUBROUTINE RegistryPointers_Case09_UnPackOutput

 SUBROUTINE RegistryPointers_Case09_C2Fary_CopyOutput( OutputData, ErrStat, ErrMsg, SkipPointers )
    TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    OutputData%DummyOutput = OutputData%C_obj%DummyOutput
 END SUBROUTINE RegistryPointers_Case09_C2Fary_CopyOutput

 SUBROUTINE RegistryPointers_Case09_F2C_CopyOutput( OutputData, ErrStat, ErrMsg, SkipPointers  )
    TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT) :: OutputData
    INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
    CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    LOGICAL,OPTIONAL,INTENT(IN   ) :: SkipPointers
    ! 
    LOGICAL                        :: SkipPointers_local
    ErrStat = ErrID_None
    ErrMsg  = ""

    IF (PRESENT(SkipPointers)) THEN
       SkipPointers_local = SkipPointers
    ELSE
       SkipPointers_local = .false.
    END IF
    OutputData%C_obj%DummyOutput = OutputData%DummyOutput
 END SUBROUTINE RegistryPointers_Case09_F2C_CopyOutput


 SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'RegistryPointers_Case09_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL RegistryPointers_Case09_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL RegistryPointers_Case09_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL RegistryPointers_Case09_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp


 SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'RegistryPointers_Case09_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
  b = -(u1%DummyInput - u2%DummyInput)
  u_out%DummyInput = u1%DummyInput + b * ScaleFactor
 END SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp1


 SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
 TYPE(RegistryPointers_Case09_InputType), INTENT(IN)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(RegistryPointers_Case09_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'RegistryPointers_Case09_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
  b = (t(3)**2*(u1%DummyInput - u2%DummyInput) + t(2)**2*(-u1%DummyInput + u3%DummyInput))* scaleFactor
  c = ( (t(2)-t(3))*u1%DummyInput + t(3)*u2%DummyInput - t(2)*u3%DummyInput ) * scaleFactor
  u_out%DummyInput = u1%DummyInput + b  + c * t_out
 END SUBROUTINE RegistryPointers_Case09_Input_ExtrapInterp2


 SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'RegistryPointers_Case09_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL RegistryPointers_Case09_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL RegistryPointers_Case09_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL RegistryPointers_Case09_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp


 SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'RegistryPointers_Case09_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
  b = -(y1%DummyOutput - y2%DummyOutput)
  y_out%DummyOutput = y1%DummyOutput + b * ScaleFactor
 END SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp1


 SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(RegistryPointers_Case09_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(RegistryPointers_Case09_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'RegistryPointers_Case09_Output_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
  b = (t(3)**2*(y1%DummyOutput - y2%DummyOutput) + t(2)**2*(-y1%DummyOutput + y3%DummyOutput))* scaleFactor
  c = ( (t(2)-t(3))*y1%DummyOutput + t(3)*y2%DummyOutput - t(2)*y3%DummyOutput ) * scaleFactor
  y_out%DummyOutput = y1%DummyOutput + b  + c * t_out
 END SUBROUTINE RegistryPointers_Case09_Output_ExtrapInterp2

END MODULE RegistryPointers_Case09_Types
!ENDOFREGISTRYGENERATEDFILE
